{
  "version": 3,
  "sources": ["../../topojson-client/dist/topojson-client.js"],
  "sourcesContent": ["// https://github.com/topojson/topojson-client v3.1.0 Copyright 2019 Mike Bostock\n(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\ntypeof define === 'function' && define.amd ? define(['exports'], factory) :\n(global = global || self, factory(global.topojson = global.topojson || {}));\n}(this, function (exports) { 'use strict';\n\nfunction identity(x) {\n  return x;\n}\n\nfunction transform(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n\nfunction bbox(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n}\n\nfunction reverse(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n\nfunction feature(topology, o) {\n  if (typeof o === \"string\") o = topology.objects[o];\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n}\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nfunction stitch(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n\nfunction mesh(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nfunction meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nfunction merge(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nfunction mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    }).filter(function(arcs) {\n      return arcs.length > 0;\n    })\n  };\n}\n\nfunction bisect(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n\nfunction neighbors(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n}\n\nfunction untransform(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n\nfunction quantize(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be â‰¥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n\nexports.bbox = bbox;\nexports.feature = feature;\nexports.merge = merge;\nexports.mergeArcs = mergeArcs;\nexports.mesh = mesh;\nexports.meshArcs = meshArcs;\nexports.neighbors = neighbors;\nexports.quantize = quantize;\nexports.transform = transform;\nexports.untransform = untransform;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],
  "mappings": "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",
  "names": ["exports", "transform", "o", "bbox", "arcs", "fragmentByEnd", "fragmentByStart", "object", "neighbors", "polygon", "polygons", "i", "n"]
}
